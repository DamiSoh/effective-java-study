## item15_클래스와_멤버의_접근_권한을_최소화하라

정보 은닉, 혹은 캡슐화라고 부르는 오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부동작에 관여하지 않는 방식은 소프트웨어 설계의 근간이 되는 원리입니다.

정보 은닉의 핵심은 접근 제한자를 잘 활용하는 것입니다.

기본 원칙은 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다는 것입니다. 

모든 접근 제한자 접근 수준
- package-private : 접근 제한자를 명시하지 않았을 때 적용되는 패키지 접근 수준입니다. 소속된 패키지 안의 모든 클래스에서 접근이 가능합니다.
- private : 멤버에만 사용이 가능하고 선언한 톱레벨 클래스 안에서만 사용할 수 있습니다.
- protected : package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있습니다.(상속)
- public : 모든 곳에서 접근할 수 있습니다.

접근 권한을 최소화해주기 위해 권한을 최소부터 필요할 때 그 다음 높은 권한의 제한자로 풀어줘야 합니다. `private -> package-private...`
(Serialize를 구현한 클래스는 의도와 다르게 공개 멤버가 됩니다.)

접근 제한자를 좁히지 못하는 제약

상위 클래스의 메서드를 재정의 하는 경우 그 접근 수준을 상위 클래스에서보다 좁게 설정할 수 없습니다.

public 클래스의 인스턴스 필드는 되도록 public이 아니어야 합니다. 외부에서 마음대로 필드를 변경할 수 없도록.


```java

public class A {
    
    private int a;
    public final int b;
}
```

배열의 특수성은 불변 멤버라도 길이가 0이 아닌 배열은 수정이 가능하단 것입니다. 해결책은 private으로 만들고 ``Collections.unmodifiableList(Array.asList(PRIVATE_VALUES))``를 만들어주는 것입니다.
두 번째 해결책은 배열을 private으로 만들고 그 복사본을 반환하는 public 메서드를 추가하는 방법입니다.
아래 반환타입과 위의 List 반환타입 중 어느 쪽이 성능이 더 낫고, 어느 쪽 반환타입이 쓰기 편할지? (배열 길이 제한이 없는 List가 쓰기 편할거고, 성능은 배열이 더 좋음. heap memory를 적게 먹으니, 변환 성능은 List가 앞섦. O(1) vs O(N))
```java

private static final Thing[] PRIVATE_VALUES = { ... };
public static final Thing[] values() {
    return PRIVATE_VALUES.clone();
}
```

Java 9 부터 모듈 시스템이 도입되면서 두 가지 암묵수준이 추가되었습니다. 패키지가 클래스들의 묶음이듯, 모듈은 패키지들의 묶음입니다.

모듈은 자신에 속한 패키지 중 공개(export)할 것들을 선언합니다. 선언한 경우 모듈 외에서도 접근이 가능합니다. 모듈은 유의사항이 따르는데, 모듈의 JAR 파일을 자신의 모듈 안이 아닌 애플리케이션의 classpath에 두면 그 모듈 안의 패키지는 마치 모듈이 없는 것처럼 행동합니다. 

이처럼 모듈은 사용에 어느정도의 제약이 따르는데, 장점을 누리려면(모듈을 사용하려면) 먼저 패키지들을 모듈 단위로 묶고, 모듈 선언에 패키지들의 모든 의존성을 명시합니다. 그런 다음 소스 트리를 재배치하고, 모듈 안으로부터 일반 패키지로의 모든 접근에 대한 특별한 조치를 취해야 합니다.

